import { computed as W, watch as J, unref as E, getCurrentScope as _e, onScopeDispose as Q, ref as k, onMounted as rt, nextTick as _t, onBeforeUnmount as ot, renderSlot as mn, isVNode as pn, Comment as vn, createTextVNode as gn, Fragment as bn, readonly as Nt, toRef as yn, isRef as se, customRef as wn, reactive as Ye, shallowRef as $e, watchEffect as mt } from "vue";
const D = typeof window < "u";
var pt;
D && ((pt = window == null ? void 0 : window.navigator) != null && pt.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Ke(e) {
  return e != null;
}
function P() {
}
const xn = Object.freeze({
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
});
Object.freeze(new Set(Object.keys(xn)));
function vt(e) {
  return e & -e;
}
function En(e, t = 0) {
  const n = new Array(e + 1).fill(0);
  function r(c, a) {
    if (!(!a || c >= e))
      for (c += 1; c <= e; )
        n[c] += a, c += vt(c);
  }
  function o(c = e) {
    if (c <= 0) return 0;
    c > e && (c = e);
    let a = c * t;
    for (; c > 0; )
      a += n[c], c -= vt(c);
    return a;
  }
  function i(c) {
    return o(c + 1) - o(c);
  }
  function s(c) {
    let a = 0, l = e;
    for (; l > a; ) {
      const f = Math.floor((a + l) / 2), d = o(f);
      if (d > c) {
        l = f;
        continue;
      } else if (d < c) {
        if (a === f)
          return o(a + 1) <= c ? a + 1 : a;
        a = f;
      } else
        return f;
    }
    return a;
  }
  return { tree: n, add: r, sum: o, get: i, boundIndex: s };
}
function Rn(e) {
  let t = parseFloat(e);
  return Number.isNaN(t) && (t = Number(e)), Number.isNaN(t) ? 0 : t;
}
const Tn = D && ("ontouchstart" in window || On() > 0), Sn = Tn ? "pointerdown" : "click";
function On() {
  return typeof navigator < "u" && (navigator.maxTouchPoints || navigator.msMaxTouchPoints) || 0;
}
function kn(e, t, n = window.Event) {
  const { type: r, bubbles: o = !1, cancelable: i = !1, ...s } = t;
  if (!Ke(r) || r === "") return !1;
  let c;
  return Ke(n) ? c = new n(r, { bubbles: o, cancelable: i }) : (c = document.createEvent("HTMLEvents"), c.initEvent(r, o, i)), Object.assign(c, s), e.dispatchEvent(c);
}
const zn = D ? requestAnimationFrame : (e) => {
  setTimeout(e, 16);
};
function Wt(e, t = 16) {
  if (typeof e != "function")
    return P;
  const n = (...i) => {
    e(...i);
  };
  if (t <= 0)
    return An(n);
  let r = 0, o;
  return function(...i) {
    const s = Date.now(), c = s - r;
    clearTimeout(o), c >= t ? (r = s, n(...i)) : o = setTimeout(
      () => {
        r = Date.now(), n(...i);
      },
      Math.max(0, t - c)
    );
  };
}
function An(e) {
  if (typeof e != "function")
    return e;
  let t = !1, n, r;
  return function(...o) {
    return n = o, t || (t = !0, r = Promise.resolve().then(() => (t = !1, r = void 0, e(...n)))), r;
  };
}
const ve = /* @__PURE__ */ new Set(), It = /* @__PURE__ */ new WeakMap();
function Cn() {
  ve.forEach((e) => {
    e(...It.get(e));
  }), ve.clear();
}
function Mn(e, ...t) {
  if (typeof e != "function")
    return e;
  It.set(e, t), !ve.has(e) && (ve.add(e), ve.size === 1 && zn(Cn));
}
function Ht(e) {
  return Array.isArray(e) ? e : [e];
}
function K(e, t, n, r) {
  if (!e)
    return P;
  const o = W(() => typeof r == "boolean" ? { capture: r } : r || {});
  let i = P;
  const s = J(
    () => E(e),
    (a) => {
      if (i(), !a)
        return;
      const { disabled: l, ...f } = o.value, d = (p) => {
        E(l) || n(p);
      };
      a.addEventListener(t, d, f), i = () => {
        a.removeEventListener(t, d, f), i = P;
      };
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    s(), i();
  };
  return _e() && Q(c), c;
}
const $t = "clickoutside", Ue = /* @__PURE__ */ new Set();
D && document.addEventListener(
  Sn,
  (e) => {
    const t = e.target, n = e.composedPath && e.composedPath();
    Ue.forEach((r) => {
      r !== t && (n ? !n.includes(r) : !r.contains(t)) && (!r.__transferElement || r.__transferElement !== t && !r.__transferElement.contains(t)) && kn(r, { type: $t });
    });
  },
  !0
);
function oo(e, t = k(null)) {
  let n = P;
  const r = J(
    () => E(t),
    (i) => {
      n(), i && (Ue.add(i), n = () => {
        Ue.delete(i), n = P;
      });
    },
    { immediate: !0, flush: "post" }
  ), o = () => {
    r(), n();
  };
  return _e() && Q(o), K(t, $t, e), t;
}
function io(e = P, t = k(null)) {
  let n;
  return rt(() => {
    _t(() => {
      const r = Vt(t.value);
      r ? (n = new MutationObserver(() => {
        r.style.display !== "none" && (typeof e == "function" && e(), n == null || n.disconnect(), n = null);
      }), n.observe(r, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        attributeFilter: ["style"]
      })) : typeof e == "function" && e();
    });
  }), ot(() => {
    n == null || n.disconnect(), n = null;
  }), t;
}
function Vt(e) {
  if (e) {
    let t = e.parentElement;
    for (; t && t !== document.body; ) {
      if (t.style.display === "none")
        return t;
      t = t.parentElement;
    }
  }
  return null;
}
function gt(e) {
  return (e == null ? void 0 : e.style.display) !== "none" ? !!Vt(e) : !0;
}
function so(e, t, n) {
  for (const r of t)
    if (e[r])
      return (o) => mn(e, r, o, () => {
        const i = n == null ? void 0 : n(o);
        return i ? Ht(i) : [];
      });
  return n || null;
}
function co(e) {
  const t = [], n = Array.isArray(e) ? [...e] : [];
  for (; n.length; ) {
    const r = n.shift();
    r !== null && (Array.isArray(r) && n.unshift(...r), !(typeof r != "string" && typeof r != "number" && (!pn(r) || r.type === vn)) && (typeof r == "string" || typeof r == "number" ? t.push(gn(String(r))) : r.type === bn && Array.isArray(r.children) ? n.unshift(r.children) : t.push(r)));
  }
  return t;
}
function Re(e) {
  const t = E(e);
  return typeof t == "string" ? D ? document.querySelector(t) : null : (t == null ? void 0 : t.$el) ?? t;
}
function ao(e) {
  return new Proxy({}, {
    get(t, n) {
      var r, o, i;
      if (e.component)
        return ((r = e.component.proxy) == null ? void 0 : r[n]) ?? ((o = e.component.exposeProxy) == null ? void 0 : o[n]) ?? ((i = e.component.exposed) == null ? void 0 : i[n]);
    }
  });
}
function lo(...e) {
  const t = k(!0), n = e[1] || P;
  function r() {
    t.value = !1;
  }
  function o() {
    t.value = !0;
  }
  const i = J(
    e[0],
    (...s) => new Promise((c, a) => {
      t.value && Promise.resolve(n(...s)).then(c).catch(a);
    }),
    e[2]
  );
  return { active: Nt(t), pause: r, resume: o, stop: i };
}
function fo(e, t) {
  return t.map((n) => yn(e, n));
}
const Ln = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
];
let ce;
if (D) {
  for (const e of Ln)
    if (e[1] in document) {
      ce = e;
      break;
    }
}
const Ge = !!ce, Bn = {
  supported: Ge,
  full: W(() => !1),
  enter: P,
  exit: P,
  toggle: P
}, qt = /* @__PURE__ */ new Set(), Je = /* @__PURE__ */ new WeakMap();
if (D && ce) {
  const e = ce[2], t = ce[4];
  document.addEventListener(
    t,
    () => {
      if (qt.forEach((n) => {
        n.value = !1;
      }), document[e]) {
        const n = Je.get(document[e]);
        n && (n.value = !0);
      }
    },
    !1
  );
}
function uo(e = k(null)) {
  const t = W({
    get: () => Re(e),
    set: (l) => {
      se(e) && (e.value = l);
    }
  });
  if (!D || !Ge)
    return { ...Bn, target: t };
  const [n, r, o] = ce, i = k(!1);
  J(
    () => Re(e),
    (l, f) => {
      f && Je.delete(f), l && Je.set(l, i);
    },
    { immediate: !0, flush: "post" }
  ), qt.add(i), _e() && Q(c);
  async function s(l = !1) {
    await c();
    const f = Re(e);
    return f && (l || !document[o]) ? (await f[n](), i.value = !0, document[o] === f) : !1;
  }
  async function c(l = !1) {
    const f = Re(e);
    return l || document[o] && document[o] === f ? (await document[r](), i.value = !1, document[o] !== f) : !1;
  }
  async function a(l = !1) {
    return i.value ? await c(l) : await s(l);
  }
  return {
    supported: Ge,
    target: t,
    full: W(() => i.value),
    enter: s,
    exit: c,
    toggle: a
  };
}
function ho(e = k(null)) {
  const t = k(!1);
  K(e, "mouseenter", n), K(e, "mouseleave", r);
  function n() {
    t.value = !0;
  }
  function r() {
    t.value = !1;
  }
  return { wrapper: e, isHover: t };
}
const Te = /* @__PURE__ */ new WeakMap(), Pn = /\s+/g, Dn = /(px|%)$/;
function mo(e) {
  const t = e.target || k(null);
  if (!D)
    return { target: t, disconnect: P };
  const { handler: n } = e;
  let r = e.root ?? document;
  const o = Ht(e.threshold || 0).join() || "0", i = m(e.rootMargin);
  Te.has(r) || Te.set(r, /* @__PURE__ */ new Map());
  const s = Te.get(r);
  s.has(o) || s.set(o, /* @__PURE__ */ new Map());
  const c = s.get(o);
  c.has(i) || c.set(i, {
    ob: new IntersectionObserver(b, { ...e, rootMargin: i }),
    count: 0,
    handlers: /* @__PURE__ */ new WeakMap()
  });
  let a = c.get(i), { ob: l, handlers: f } = a, d = P;
  const p = J(
    () => E(t),
    (v) => {
      d(), !(!v || !l) && (f.set(v, n), l.observe(v), a && a.count++, d = () => {
        l.unobserve(v), f.delete(v), a && a.count--, d = P;
      });
    },
    { immediate: !0, flush: "post" }
  );
  _e() && Q(g);
  function m(v) {
    if (!v || !v.trim()) return "_";
    const h = v.trim().split(Pn, 4);
    h.length = 4;
    for (let u = 0; u < 4; ++u) {
      const y = h[u];
      h[u] = Dn.test(y) ? y : `${Rn(y)}px`;
    }
    return h.join(" ");
  }
  function b(v) {
    for (let h = 0, u = v.length; h < u; ++h) {
      const y = v[h], O = f.get(y.target);
      typeof O == "function" && O(y);
    }
  }
  function g() {
    p(), d(), a && (a.count <= 0 && (c.delete(i), c.size || (s.delete(o), s.size || Te.delete(r))), a = void 0, l = void 0, f = void 0, r = void 0);
  }
  return { target: t, disconnect: g };
}
function po() {
  const e = /* @__PURE__ */ new Set();
  function t(r) {
    return wn((o, i) => {
      let s = r;
      const c = () => {
        r !== s && (s = r, i());
      };
      return {
        get: () => (o(), r),
        set: (a) => {
          a !== r && (r = a, e.add(c));
        }
      };
    });
  }
  function n() {
    for (const r of e)
      r();
    e.clear();
  }
  return { updateSet: e, manualRef: t, triggerUpdate: n };
}
const Fn = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
}, _n = /[+_-]/, Nn = /[+_-]/g, Wn = ["activeKeys", "resetAll"];
function vo(e = {}) {
  const {
    autoReset: t = !0,
    capture: n = !1,
    passive: r = !0,
    strictTarget: o = !1,
    onKeyDown: i = P,
    onKeyUp: s = P
  } = e, c = e.target || k(null), a = se(e.disabled) ? e.disabled : k(e.disabled || !1), l = { ...Fn, ...e.aliasMap || {} }, f = Ye(/* @__PURE__ */ new Set()), d = /* @__PURE__ */ new Set(), p = Ye({ activeKeys: f, resetAll: g });
  function m(h, u) {
    h in p && (p[h] = u);
  }
  function b(h, u) {
    var S, C;
    const y = (S = h.key) == null ? void 0 : S.toLocaleLowerCase(), R = [(C = h.code) == null ? void 0 : C.toLocaleLowerCase(), y].filter(Boolean);
    for (const z of R)
      f[u ? "add" : "delete"](z), m(z, u);
    if (!u && y === "meta") {
      for (const z of d)
        f.delete(z), m(z, !1);
      d.clear();
    } else if (u && typeof h.getModifierState == "function" && h.getModifierState("Meta"))
      for (const z of [...f, ...R])
        d.add(z);
  }
  function g() {
    Object.keys(p).forEach((h) => {
      p[h] = !1;
    }), p.activeKeys = f, p.resetAll = g;
  }
  const v = new Proxy(p, {
    get(h, u, y) {
      if (typeof u != "string" || Wn.includes(u))
        return Reflect.get(h, u, y);
      if (u = u.toLocaleLowerCase(), u in l && (u = l[u]), !(u in p))
        if (_n.test(u)) {
          const O = u.split(Nn).map((R) => R.trim());
          p[u] = W(() => O.every((R) => E(v[R])));
        } else
          p[u] = k(f.has(u));
      return E(Reflect.get(h, u, y));
    }
  });
  return K(
    c,
    "keydown",
    (h) => {
      o && h.target !== E(c) || (b(h, !0), i(h, v));
    },
    { capture: n, passive: r, disabled: a }
  ), K(
    c,
    "keyup",
    (h) => {
      o && h.target !== E(c) || (b(h, !1), s(h, v));
    },
    { capture: n, passive: r, disabled: a }
  ), t && K(c, "blur", g, { capture: n, passive: r, disabled: a }), { target: c, modifier: v };
}
function go(e) {
  const t = k(!1), n = () => t.value = !0;
  return rt(() => {
    e === "tick" ? _t(n) : e === "frame" ? requestAnimationFrame(n) : n();
  }), ot(() => {
    t.value = !1;
  }), { isMounted: Nt(t) };
}
function Ve(e) {
  e.cancelable && (e.stopPropagation(), e.preventDefault());
}
function bo(e) {
  const t = e.target || k(null), n = se(e.x) ? e.x : k(0), r = se(e.y) ? e.y : k(0), o = se(e.lazy) ? e.lazy : k(e.lazy || !1), i = se(e.disabled) ? e.disabled : k(e.disabled || !1), { capture: s = !0, stopMouse: c = !0, stopTouch: a = !0 } = e, l = k(!1), f = {
    xStart: 0,
    yStart: 0,
    xEnd: 0,
    yEnd: 0,
    clientX: 0,
    clientY: 0,
    deltaX: 0,
    deltaY: 0,
    lazy: !1
  };
  let d = 0, p = 0;
  const m = Wt((u) => {
    var y;
    p < d || (h(u), f.lazy || (n.value = f.xEnd, r.value = f.yEnd), (y = e.onMove) == null || y.call(e, f, u));
  });
  function b(u) {
    var y;
    i.value || (Object.assign(f, {
      xStart: n.value,
      yStart: r.value,
      xEnd: n.value,
      yEnd: r.value,
      clientX: u.clientX,
      clientY: u.clientY,
      lazy: o.value
    }), ((y = e.onStart) == null ? void 0 : y.call(e, f, u)) !== !1 && (document.addEventListener("pointermove", g, { capture: s }), document.addEventListener("pointerup", v, { capture: s }), p = d, l.value = !0));
  }
  function g(u) {
    i.value || (Ve(u), m(u));
  }
  function v(u) {
    var y;
    document.removeEventListener("pointermove", g, { capture: s }), document.removeEventListener("pointerup", v, { capture: s }), !i.value && (h(u), f.lazy && (n.value = f.xEnd, r.value = f.yEnd), l.value = !1, ++d, (y = e.onEnd) == null || y.call(e, f, u));
  }
  function h(u) {
    const { clientX: y, clientY: O } = u, { xStart: R, yStart: S, clientX: C, clientY: z } = f, L = y - C, B = O - z;
    f.deltaX = L, f.deltaY = B, f.xEnd = R + L, f.yEnd = S + B;
  }
  return K(t, "pointerdown", b, { capture: s }), c && K(t, "mousedown", Ve, { capture: s }), a && K(t, "touchstart", Ve, { capture: s }), {
    target: t,
    moving: W(() => l.value),
    x: n,
    y: r,
    lazy: o,
    disabled: i
  };
}
const be = /* @__PURE__ */ new Set(), U = /* @__PURE__ */ new Map();
U.set("x", 0);
U.set("y", 0);
function In(e) {
  const { pageX: t, pageY: n } = e;
  U.set("x", t), U.set("y", n), be.forEach((r) => {
    r.x.value = t, r.y.value = n;
  });
}
const Xt = Wt(In);
function Hn(e) {
  !be.size && window && (U.set("x", 0), U.set("y", 0), window.addEventListener("pointermove", Xt, { passive: !0 })), be.add(e);
}
function bt(e) {
  be.delete(e), !be.size && window && window.removeEventListener("pointermove", Xt);
}
function yo(e = {}) {
  const t = k(e.x ?? U.get("x")), n = k(e.y ?? U.get("y")), r = { x: t, y: n };
  return Hn(r), e.manualStop || ot(() => {
    bt(r);
  }), { ...r, unregister: () => bt(r) };
}
const $n = ["top", "right", "bottom", "left"], fe = Math.min, te = Math.max, Me = Math.round, Se = Math.floor, X = (e) => ({
  x: e,
  y: e
}), Vn = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, qn = {
  start: "end",
  end: "start"
};
function Qe(e, t, n) {
  return te(e, fe(t, n));
}
function he(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function oe(e) {
  return e.split("-")[0];
}
function xe(e) {
  return e.split("-")[1];
}
function jt(e) {
  return e === "x" ? "y" : "x";
}
function it(e) {
  return e === "y" ? "height" : "width";
}
function ue(e) {
  return ["top", "bottom"].includes(oe(e)) ? "y" : "x";
}
function st(e) {
  return jt(ue(e));
}
function Xn(e, t, n) {
  n === void 0 && (n = !1);
  const r = xe(e), o = st(e), i = it(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (s = Le(s)), [s, Le(s)];
}
function jn(e) {
  const t = Le(e);
  return [Ze(e), t, Ze(t)];
}
function Ze(e) {
  return e.replace(/start|end/g, (t) => qn[t]);
}
function Yn(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i : s;
    default:
      return [];
  }
}
function Kn(e, t, n, r) {
  const o = xe(e);
  let i = Yn(oe(e), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), t && (i = i.concat(i.map(Ze)))), i;
}
function Le(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Vn[t]);
}
function Un(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Yt(e) {
  return typeof e != "number" ? Un(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Be(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function yt(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = ue(t), s = st(t), c = it(s), a = oe(t), l = i === "y", f = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, p = r[c] / 2 - o[c] / 2;
  let m;
  switch (a) {
    case "top":
      m = {
        x: f,
        y: r.y - o.height
      };
      break;
    case "bottom":
      m = {
        x: f,
        y: r.y + r.height
      };
      break;
    case "right":
      m = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      m = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      m = {
        x: r.x,
        y: r.y
      };
  }
  switch (xe(t)) {
    case "start":
      m[s] -= p * (n && l ? -1 : 1);
      break;
    case "end":
      m[s] += p * (n && l ? -1 : 1);
      break;
  }
  return m;
}
const Gn = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, c = i.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let l = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: f,
    y: d
  } = yt(l, r, a), p = r, m = {}, b = 0;
  for (let g = 0; g < c.length; g++) {
    const {
      name: v,
      fn: h
    } = c[g], {
      x: u,
      y,
      data: O,
      reset: R
    } = await h({
      x: f,
      y: d,
      initialPlacement: r,
      placement: p,
      strategy: o,
      middlewareData: m,
      rects: l,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    f = u ?? f, d = y ?? d, m = {
      ...m,
      [v]: {
        ...m[v],
        ...O
      }
    }, R && b <= 50 && (b++, typeof R == "object" && (R.placement && (p = R.placement), R.rects && (l = R.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : R.rects), {
      x: f,
      y: d
    } = yt(l, p, a)), g = -1);
  }
  return {
    x: f,
    y: d,
    placement: p,
    strategy: o,
    middlewareData: m
  };
};
async function Pe(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: c,
    strategy: a
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: m = 0
  } = he(t, e), b = Yt(m), v = c[p ? d === "floating" ? "reference" : "floating" : d], h = Be(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(v))) == null || n ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(c.floating)),
    boundary: l,
    rootBoundary: f,
    strategy: a
  })), u = d === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, y = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c.floating)), O = await (i.isElement == null ? void 0 : i.isElement(y)) ? await (i.getScale == null ? void 0 : i.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, R = Be(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: u,
    offsetParent: y,
    strategy: a
  }) : u);
  return {
    top: (h.top - R.top + b.top) / O.y,
    bottom: (R.bottom - h.bottom + b.bottom) / O.y,
    left: (h.left - R.left + b.left) / O.x,
    right: (R.right - h.right + b.right) / O.x
  };
}
const Jn = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: c,
      middlewareData: a
    } = t, {
      element: l,
      padding: f = 0
    } = he(e, t) || {};
    if (l == null)
      return {};
    const d = Yt(f), p = {
      x: n,
      y: r
    }, m = st(o), b = it(m), g = await s.getDimensions(l), v = m === "y", h = v ? "top" : "left", u = v ? "bottom" : "right", y = v ? "clientHeight" : "clientWidth", O = i.reference[b] + i.reference[m] - p[m] - i.floating[b], R = p[m] - i.reference[m], S = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l));
    let C = S ? S[y] : 0;
    (!C || !await (s.isElement == null ? void 0 : s.isElement(S))) && (C = c.floating[y] || i.floating[b]);
    const z = O / 2 - R / 2, L = C / 2 - g[b] / 2 - 1, B = fe(d[h], L), H = fe(d[u], L), _ = B, w = C - g[b] - H, x = C / 2 - g[b] / 2 + z, T = Qe(_, x, w), M = !a.arrow && xe(o) != null && x !== T && i.reference[b] / 2 - (x < _ ? B : H) - g[b] / 2 < 0, A = M ? x < _ ? x - _ : x - w : 0;
    return {
      [m]: p[m] + A,
      data: {
        [m]: T,
        centerOffset: x - T - A,
        ...M && {
          alignmentOffset: A
        }
      },
      reset: M
    };
  }
}), Qn = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: c,
        platform: a,
        elements: l
      } = t, {
        mainAxis: f = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: g = !0,
        ...v
      } = he(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const h = oe(o), u = ue(c), y = oe(c) === c, O = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), R = p || (y || !g ? [Le(c)] : jn(c)), S = b !== "none";
      !p && S && R.push(...Kn(c, g, b, O));
      const C = [c, ...R], z = await Pe(t, v), L = [];
      let B = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (f && L.push(z[h]), d) {
        const x = Xn(o, s, O);
        L.push(z[x[0]], z[x[1]]);
      }
      if (B = [...B, {
        placement: o,
        overflows: L
      }], !L.every((x) => x <= 0)) {
        var H, _;
        const x = (((H = i.flip) == null ? void 0 : H.index) || 0) + 1, T = C[x];
        if (T)
          return {
            data: {
              index: x,
              overflows: B
            },
            reset: {
              placement: T
            }
          };
        let M = (_ = B.filter((A) => A.overflows[0] <= 0).sort((A, N) => A.overflows[1] - N.overflows[1])[0]) == null ? void 0 : _.placement;
        if (!M)
          switch (m) {
            case "bestFit": {
              var w;
              const A = (w = B.filter((N) => {
                if (S) {
                  const F = ue(N.placement);
                  return F === u || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  F === "y";
                }
                return !0;
              }).map((N) => [N.placement, N.overflows.filter((F) => F > 0).reduce((F, Z) => F + Z, 0)]).sort((N, F) => N[1] - F[1])[0]) == null ? void 0 : w[0];
              A && (M = A);
              break;
            }
            case "initialPlacement":
              M = c;
              break;
          }
        if (o !== M)
          return {
            reset: {
              placement: M
            }
          };
      }
      return {};
    }
  };
};
function wt(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function xt(e) {
  return $n.some((t) => e[t] >= 0);
}
const Zn = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = he(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await Pe(t, {
            ...o,
            elementContext: "reference"
          }), s = wt(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: xt(s)
            }
          };
        }
        case "escaped": {
          const i = await Pe(t, {
            ...o,
            altBoundary: !0
          }), s = wt(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: xt(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function er(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = oe(n), c = xe(n), a = ue(n) === "y", l = ["left", "top"].includes(s) ? -1 : 1, f = i && a ? -1 : 1, d = he(t, e);
  let {
    mainAxis: p,
    crossAxis: m,
    alignmentAxis: b
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return c && typeof b == "number" && (m = c === "end" ? b * -1 : b), a ? {
    x: m * f,
    y: p * l
  } : {
    x: p * l,
    y: m * f
  };
}
const tr = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: c
      } = t, a = await er(t, e);
      return s === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: o + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: s
        }
      };
    }
  };
}, nr = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: c = {
          fn: (v) => {
            let {
              x: h,
              y: u
            } = v;
            return {
              x: h,
              y: u
            };
          }
        },
        ...a
      } = he(e, t), l = {
        x: n,
        y: r
      }, f = await Pe(t, a), d = ue(oe(o)), p = jt(d);
      let m = l[p], b = l[d];
      if (i) {
        const v = p === "y" ? "top" : "left", h = p === "y" ? "bottom" : "right", u = m + f[v], y = m - f[h];
        m = Qe(u, m, y);
      }
      if (s) {
        const v = d === "y" ? "top" : "left", h = d === "y" ? "bottom" : "right", u = b + f[v], y = b - f[h];
        b = Qe(u, b, y);
      }
      const g = c.fn({
        ...t,
        [p]: m,
        [d]: b
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - r,
          enabled: {
            [p]: i,
            [d]: s
          }
        }
      };
    }
  };
};
function Ne() {
  return typeof window < "u";
}
function me(e) {
  return Kt(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function I(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Y(e) {
  var t;
  return (t = (Kt(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Kt(e) {
  return Ne() ? e instanceof Node || e instanceof I(e).Node : !1;
}
function $(e) {
  return Ne() ? e instanceof Element || e instanceof I(e).Element : !1;
}
function j(e) {
  return Ne() ? e instanceof HTMLElement || e instanceof I(e).HTMLElement : !1;
}
function Et(e) {
  return !Ne() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof I(e).ShadowRoot;
}
function Ee(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = V(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function rr(e) {
  return ["table", "td", "th"].includes(me(e));
}
function We(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function ct(e) {
  const t = at(), n = $(e) ? V(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function or(e) {
  let t = G(e);
  for (; j(t) && !de(t); ) {
    if (ct(t))
      return t;
    if (We(t))
      return null;
    t = G(t);
  }
  return null;
}
function at() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function de(e) {
  return ["html", "body", "#document"].includes(me(e));
}
function V(e) {
  return I(e).getComputedStyle(e);
}
function Ie(e) {
  return $(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function G(e) {
  if (me(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Et(e) && e.host || // Fallback.
    Y(e)
  );
  return Et(t) ? t.host : t;
}
function Ut(e) {
  const t = G(e);
  return de(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : j(t) && Ee(t) ? t : Ut(t);
}
function ye(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = Ut(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = I(o);
  if (i) {
    const c = et(s);
    return t.concat(s, s.visualViewport || [], Ee(o) ? o : [], c && n ? ye(c) : []);
  }
  return t.concat(o, ye(o, [], n));
}
function et(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Gt(e) {
  const t = V(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = j(e), i = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, c = Me(n) !== i || Me(r) !== s;
  return c && (n = i, r = s), {
    width: n,
    height: r,
    $: c
  };
}
function lt(e) {
  return $(e) ? e : e.contextElement;
}
function ae(e) {
  const t = lt(e);
  if (!j(t))
    return X(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = Gt(t);
  let s = (i ? Me(n.width) : n.width) / r, c = (i ? Me(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const ir = /* @__PURE__ */ X(0);
function Jt(e) {
  const t = I(e);
  return !at() || !t.visualViewport ? ir : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function sr(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== I(e) ? !1 : t;
}
function ie(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = lt(e);
  let s = X(1);
  t && (r ? $(r) && (s = ae(r)) : s = ae(e));
  const c = sr(i, n, r) ? Jt(i) : X(0);
  let a = (o.left + c.x) / s.x, l = (o.top + c.y) / s.y, f = o.width / s.x, d = o.height / s.y;
  if (i) {
    const p = I(i), m = r && $(r) ? I(r) : r;
    let b = p, g = et(b);
    for (; g && r && m !== b; ) {
      const v = ae(g), h = g.getBoundingClientRect(), u = V(g), y = h.left + (g.clientLeft + parseFloat(u.paddingLeft)) * v.x, O = h.top + (g.clientTop + parseFloat(u.paddingTop)) * v.y;
      a *= v.x, l *= v.y, f *= v.x, d *= v.y, a += y, l += O, b = I(g), g = et(b);
    }
  }
  return Be({
    width: f,
    height: d,
    x: a,
    y: l
  });
}
function ft(e, t) {
  const n = Ie(e).scrollLeft;
  return t ? t.left + n : ie(Y(e)).left + n;
}
function Qt(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    ft(e, r)
  )), i = r.top + t.scrollTop;
  return {
    x: o,
    y: i
  };
}
function cr(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const i = o === "fixed", s = Y(r), c = t ? We(t.floating) : !1;
  if (r === s || c && i)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = X(1);
  const f = X(0), d = j(r);
  if ((d || !d && !i) && ((me(r) !== "body" || Ee(s)) && (a = Ie(r)), j(r))) {
    const m = ie(r);
    l = ae(r), f.x = m.x + r.clientLeft, f.y = m.y + r.clientTop;
  }
  const p = s && !d && !i ? Qt(s, a, !0) : X(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - a.scrollLeft * l.x + f.x + p.x,
    y: n.y * l.y - a.scrollTop * l.y + f.y + p.y
  };
}
function ar(e) {
  return Array.from(e.getClientRects());
}
function lr(e) {
  const t = Y(e), n = Ie(e), r = e.ownerDocument.body, o = te(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = te(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + ft(e);
  const c = -n.scrollTop;
  return V(r).direction === "rtl" && (s += te(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: c
  };
}
function fr(e, t) {
  const n = I(e), r = Y(e), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, c = 0, a = 0;
  if (o) {
    i = o.width, s = o.height;
    const l = at();
    (!l || l && t === "fixed") && (c = o.offsetLeft, a = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: c,
    y: a
  };
}
function ur(e, t) {
  const n = ie(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = j(e) ? ae(e) : X(1), s = e.clientWidth * i.x, c = e.clientHeight * i.y, a = o * i.x, l = r * i.y;
  return {
    width: s,
    height: c,
    x: a,
    y: l
  };
}
function Rt(e, t, n) {
  let r;
  if (t === "viewport")
    r = fr(e, n);
  else if (t === "document")
    r = lr(Y(e));
  else if ($(t))
    r = ur(t, n);
  else {
    const o = Jt(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return Be(r);
}
function Zt(e, t) {
  const n = G(e);
  return n === t || !$(n) || de(n) ? !1 : V(n).position === "fixed" || Zt(n, t);
}
function dr(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = ye(e, [], !1).filter((c) => $(c) && me(c) !== "body"), o = null;
  const i = V(e).position === "fixed";
  let s = i ? G(e) : e;
  for (; $(s) && !de(s); ) {
    const c = V(s), a = ct(s);
    !a && c.position === "fixed" && (o = null), (i ? !a && !o : !a && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || Ee(s) && !a && Zt(e, s)) ? r = r.filter((f) => f !== s) : o = c, s = G(s);
  }
  return t.set(e, r), r;
}
function hr(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? We(t) ? [] : dr(t, this._c) : [].concat(n), r], c = s[0], a = s.reduce((l, f) => {
    const d = Rt(t, f, o);
    return l.top = te(d.top, l.top), l.right = fe(d.right, l.right), l.bottom = fe(d.bottom, l.bottom), l.left = te(d.left, l.left), l;
  }, Rt(t, c, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function mr(e) {
  const {
    width: t,
    height: n
  } = Gt(e);
  return {
    width: t,
    height: n
  };
}
function pr(e, t, n) {
  const r = j(t), o = Y(t), i = n === "fixed", s = ie(e, !0, i, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = X(0);
  if (r || !r && !i)
    if ((me(t) !== "body" || Ee(o)) && (c = Ie(t)), r) {
      const p = ie(t, !0, i, t);
      a.x = p.x + t.clientLeft, a.y = p.y + t.clientTop;
    } else o && (a.x = ft(o));
  const l = o && !r && !i ? Qt(o, c) : X(0), f = s.left + c.scrollLeft - a.x - l.x, d = s.top + c.scrollTop - a.y - l.y;
  return {
    x: f,
    y: d,
    width: s.width,
    height: s.height
  };
}
function qe(e) {
  return V(e).position === "static";
}
function Tt(e, t) {
  if (!j(e) || V(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Y(e) === n && (n = n.ownerDocument.body), n;
}
function en(e, t) {
  const n = I(e);
  if (We(e))
    return n;
  if (!j(e)) {
    let o = G(e);
    for (; o && !de(o); ) {
      if ($(o) && !qe(o))
        return o;
      o = G(o);
    }
    return n;
  }
  let r = Tt(e, t);
  for (; r && rr(r) && qe(r); )
    r = Tt(r, t);
  return r && de(r) && qe(r) && !ct(r) ? n : r || or(e) || n;
}
const vr = async function(e) {
  const t = this.getOffsetParent || en, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: pr(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function gr(e) {
  return V(e).direction === "rtl";
}
const tn = {
  convertOffsetParentRelativeRectToViewportRelativeRect: cr,
  getDocumentElement: Y,
  getClippingRect: hr,
  getOffsetParent: en,
  getElementRects: vr,
  getClientRects: ar,
  getDimensions: mr,
  getScale: ae,
  isElement: $,
  isRTL: gr
};
function nn(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function br(e, t) {
  let n = null, r;
  const o = Y(e);
  function i() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), i();
    const l = e.getBoundingClientRect(), {
      left: f,
      top: d,
      width: p,
      height: m
    } = l;
    if (c || t(), !p || !m)
      return;
    const b = Se(d), g = Se(o.clientWidth - (f + p)), v = Se(o.clientHeight - (d + m)), h = Se(f), y = {
      rootMargin: -b + "px " + -g + "px " + -v + "px " + -h + "px",
      threshold: te(0, fe(1, a)) || 1
    };
    let O = !0;
    function R(S) {
      const C = S[0].intersectionRatio;
      if (C !== a) {
        if (!O)
          return s();
        C ? s(!1, C) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      C === 1 && !nn(l, e.getBoundingClientRect()) && s(), O = !1;
    }
    try {
      n = new IntersectionObserver(R, {
        ...y,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(R, y);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function yr(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, l = lt(e), f = o || i ? [...l ? ye(l) : [], ...ye(t)] : [];
  f.forEach((h) => {
    o && h.addEventListener("scroll", n, {
      passive: !0
    }), i && h.addEventListener("resize", n);
  });
  const d = l && c ? br(l, n) : null;
  let p = -1, m = null;
  s && (m = new ResizeObserver((h) => {
    let [u] = h;
    u && u.target === l && m && (m.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var y;
      (y = m) == null || y.observe(t);
    })), n();
  }), l && !a && m.observe(l), m.observe(t));
  let b, g = a ? ie(e) : null;
  a && v();
  function v() {
    const h = ie(e);
    g && !nn(g, h) && n(), g = h, b = requestAnimationFrame(v);
  }
  return n(), () => {
    var h;
    f.forEach((u) => {
      o && u.removeEventListener("scroll", n), i && u.removeEventListener("resize", n);
    }), d == null || d(), (h = m) == null || h.disconnect(), m = null, a && cancelAnimationFrame(b);
  };
}
const wr = tr, xr = nr, Er = Qn, Rr = Zn, Tr = Jn, Sr = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: tn,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return Gn(e, t, {
    ...o,
    platform: i
  });
};
var ne = [], Or = function() {
  return ne.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, kr = function() {
  return ne.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, St = "ResizeObserver loop completed with undelivered notifications.", zr = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: St
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = St), window.dispatchEvent(e);
}, we;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(we || (we = {}));
var re = function(e) {
  return Object.freeze(e);
}, Ar = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, re(this);
  }
  return e;
}(), rn = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, re(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, c = t.left, a = t.width, l = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: c, width: a, height: l };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), ut = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, on = function(e) {
  if (ut(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, Ot = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Cr = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ge = typeof window < "u" ? window : {}, Oe = /* @__PURE__ */ new WeakMap(), kt = /auto|scroll/, Mr = /^tb|vertical/, Lr = /msie|trident/i.test(ge.navigator && ge.navigator.userAgent), q = function(e) {
  return parseFloat(e || "0");
}, le = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Ar((n ? t : e) || 0, (n ? e : t) || 0);
}, zt = re({
  devicePixelContentBoxSize: le(),
  borderBoxSize: le(),
  contentBoxSize: le(),
  contentRect: new rn(0, 0, 0, 0)
}), sn = function(e, t) {
  if (t === void 0 && (t = !1), Oe.has(e) && !t)
    return Oe.get(e);
  if (on(e))
    return Oe.set(e, zt), zt;
  var n = getComputedStyle(e), r = ut(e) && e.ownerSVGElement && e.getBBox(), o = !Lr && n.boxSizing === "border-box", i = Mr.test(n.writingMode || ""), s = !r && kt.test(n.overflowY || ""), c = !r && kt.test(n.overflowX || ""), a = r ? 0 : q(n.paddingTop), l = r ? 0 : q(n.paddingRight), f = r ? 0 : q(n.paddingBottom), d = r ? 0 : q(n.paddingLeft), p = r ? 0 : q(n.borderTopWidth), m = r ? 0 : q(n.borderRightWidth), b = r ? 0 : q(n.borderBottomWidth), g = r ? 0 : q(n.borderLeftWidth), v = d + l, h = a + f, u = g + m, y = p + b, O = c ? e.offsetHeight - y - e.clientHeight : 0, R = s ? e.offsetWidth - u - e.clientWidth : 0, S = o ? v + u : 0, C = o ? h + y : 0, z = r ? r.width : q(n.width) - S - R, L = r ? r.height : q(n.height) - C - O, B = z + v + R + u, H = L + h + O + y, _ = re({
    devicePixelContentBoxSize: le(Math.round(z * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: le(B, H, i),
    contentBoxSize: le(z, L, i),
    contentRect: new rn(d, a, z, L)
  });
  return Oe.set(e, _), _;
}, cn = function(e, t, n) {
  var r = sn(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case we.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case we.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, Br = /* @__PURE__ */ function() {
  function e(t) {
    var n = sn(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = re([n.borderBoxSize]), this.contentBoxSize = re([n.contentBoxSize]), this.devicePixelContentBoxSize = re([n.devicePixelContentBoxSize]);
  }
  return e;
}(), an = function(e) {
  if (on(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Pr = function() {
  var e = 1 / 0, t = [];
  ne.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var c = [];
      s.activeTargets.forEach(function(l) {
        var f = new Br(l.target), d = an(l.target);
        c.push(f), l.lastReportedSize = cn(l.target, l.observedBox), d < e && (e = d);
      }), t.push(function() {
        s.callback.call(s.observer, c, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, At = function(e) {
  ne.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (an(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Dr = function() {
  var e = 0;
  for (At(e); Or(); )
    e = Pr(), At(e);
  return kr() && zr(), e > 0;
}, Xe, ln = [], Fr = function() {
  return ln.splice(0).forEach(function(e) {
    return e();
  });
}, _r = function(e) {
  if (!Xe) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return Fr();
    }).observe(n, r), Xe = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  ln.push(e), Xe();
}, Nr = function(e) {
  _r(function() {
    requestAnimationFrame(e);
  });
}, Ae = 0, Wr = function() {
  return !!Ae;
}, Ir = 250, Hr = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Ct = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], Mt = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, je = !1, $r = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = Ir), !je) {
      je = !0;
      var r = Mt(t);
      Nr(function() {
        var o = !1;
        try {
          o = Dr();
        } finally {
          if (je = !1, t = r - Mt(), !Wr())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, Hr);
    };
    document.body ? n() : ge.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Ct.forEach(function(n) {
      return ge.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), Ct.forEach(function(n) {
      return ge.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), tt = new $r(), Lt = function(e) {
  !Ae && e > 0 && tt.start(), Ae += e, !Ae && tt.stop();
}, Vr = function(e) {
  return !ut(e) && !Cr(e) && getComputedStyle(e).display === "inline";
}, qr = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || we.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = cn(this.target, this.observedBox, !0);
    return Vr(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), Xr = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), ke = /* @__PURE__ */ new WeakMap(), Bt = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, ze = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new Xr(t, n);
    ke.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = ke.get(t), i = o.observationTargets.length === 0;
    Bt(o.observationTargets, n) < 0 && (i && ne.push(o), o.observationTargets.push(new qr(n, r && r.box)), Lt(1), tt.schedule());
  }, e.unobserve = function(t, n) {
    var r = ke.get(t), o = Bt(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && ne.splice(ne.indexOf(r), 1), r.observationTargets.splice(o, 1), Lt(-1));
  }, e.disconnect = function(t) {
    var n = this, r = ke.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), Pt = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    ze.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Ot(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ze.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Ot(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ze.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    ze.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
const De = /* @__PURE__ */ new WeakMap();
function jr(e) {
  for (let t = 0, n = e.length; t < n; ++t) {
    const r = e[t], o = De.get(r.target);
    typeof o == "function" && o(r);
  }
}
const fn = new (D && window.ResizeObserver || Pt)(
  jr
);
function He(e, t) {
  De.set(e, t), fn.observe(e);
}
function un(e) {
  De.has(e) && (fn.unobserve(e), De.delete(e));
}
function wo() {
  return {
    observeResize: He,
    unobserveResize: un
  };
}
const dn = k(!1), Yr = W(() => dn.value), pe = "__rtl_observer__";
function Kr() {
  return D && !document.querySelector(`#${pe}`) && Ur(), { isRtl: Yr };
}
function Ur() {
  if (!D) return;
  const e = document.createElement("style"), t = `#${pe} { width: 1px } html.rtl #${pe}, html[dir='rtl'] #${pe} { width: 2px }`;
  e.textContent = t, document.head.appendChild(e);
  const n = document.createElement("div");
  n.id = pe, n.role = "none", n.style.cssText = "position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;", He(n, () => {
    D && (dn.value = document.documentElement.classList.contains("rtl") || document.documentElement.getAttribute("dir") === "rtl");
  }), document.body.appendChild(n);
}
const xo = Object.freeze([
  "top",
  "top-start",
  "top-end",
  "bottom",
  "bottom-start",
  "bottom-end",
  "left",
  "left-start",
  "left-end",
  "right",
  "right-start",
  "right-end"
]);
function Eo(e) {
  const { transfer: t, wrapper: n, isDrop: r = !1 } = e, o = e.reference ?? $e(null), i = e.popper ?? $e(null), s = e.arrow ?? $e(null), c = k(E(e.placement)), a = k(""), l = e.isRtl ?? Kr().isRtl;
  n && mt(() => {
    const g = E(n), v = E(i);
    g && (g.__transferElement = v);
  }), t != null && (J(
    () => E(t),
    (g) => {
      m(g), p();
    }
  ), m(E(t))), rt(() => {
    requestAnimationFrame(() => {
      mt(d);
    });
  });
  let f;
  async function d() {
    if (!D) return;
    f == null || f();
    const g = E(o), v = E(i);
    if (!g || !v) return;
    const h = E(s), u = [Er()];
    if (r && u.push({
      name: "origin",
      fn({ placement: S, elements: C }) {
        const z = b(S);
        return z && (C.floating.style.transformOrigin = z), {};
      }
    }), e.offset) {
      let S = E(e.offset);
      Array.isArray(S) && (S = {
        mainAxis: S[1],
        crossAxis: S[0]
      }), u.push(wr(S));
    }
    if (e.shift) {
      let S = E(e.shift);
      typeof S == "boolean" && (S = {}), u.push(xr(S));
    }
    h && u.push(Tr({ element: h })), u.push(Rr({ strategy: "escaped" }));
    const y = E(l) || !1, O = {
      middleware: u,
      placement: E(e.placement),
      platform: {
        ...tn,
        isRTL: async () => y
      }
    }, R = async () => {
      const {
        x: S,
        y: C,
        placement: z,
        strategy: L,
        middlewareData: B
      } = await Sr(g, v, O);
      if (E(o) !== g) {
        E(i) === v && Object.assign(v.style, {
          position: "",
          top: "",
          left: ""
        });
        return;
      }
      const H = {
        position: L,
        top: `${C}px`,
        left: `${S}px`
      };
      if (h)
        if (B.arrow) {
          const { x: _, y: w } = B.arrow;
          Object.assign(h.style, {
            top: w != null ? `${w}px` : "",
            left: _ != null ? `${_}px` : ""
          });
        } else
          Object.assign(h.style, { top: "", left: "" });
      Object.assign(v.style, H), v.dataset.popperPlacement = z, c.value = z;
    };
    e.autoUpdate && (f = yr(g, v, R)), await R();
  }
  const p = () => new Promise((g) => {
    requestAnimationFrame(() => {
      d().then(g);
    });
  });
  function m(g) {
    a.value = typeof g == "boolean" ? g ? "body" : "" : g;
  }
  function b(g) {
    if (g !== "left" && g !== "right") {
      const [v, h] = g.split("-");
      return v === "bottom" || v !== "top" && h === "start" ? "center top" : "center bottom";
    }
  }
  return {
    wrapper: n,
    reference: o,
    popper: i,
    placement: c,
    transferTo: a,
    updatePopper: p
  };
}
const Dt = "__theme_style__", Ce = "__theme_observer__", Ft = /* @__PURE__ */ new WeakMap();
function Ro(e) {
  const t = k();
  if (D) {
    e = e || document.body;
    let n = Ft.get(e);
    n || (n = Zr(t), e.appendChild(n), Ft.set(e, n));
  }
  return { theme: t };
}
const Fe = Ye(/* @__PURE__ */ new Map()), nt = /* @__PURE__ */ new Map();
J(Fe, () => {
  if (!D) return;
  nt.clear();
  const e = document.head.querySelector(`#${Dt}`);
  e && document.head.removeChild(e);
  const t = document.createElement("style");
  let n = `.${Ce} { width: 1px }`, r = 1;
  for (const [o, [i, s]] of Fe.entries())
    n += ` html.${i} .${Ce}, .${s} .${Ce} { width: ${++r}px }`, nt.set(r, o);
  t.textContent = n, t.id = Dt, document.head.appendChild(t);
});
function Gr(e) {
  for (const t of e) {
    const {
      name: n,
      rootClass: r = n,
      varsClass: o = `vxp-theme-vars-${r}`
    } = typeof t == "string" ? { name: t } : t;
    Fe.set(n, [r, o]);
  }
}
function To(e) {
  Fe.clear(), Gr(e);
}
let Jr = 0;
function Qr() {
  return `__theme_observer_${Jr++}__`;
}
function Zr(e) {
  if (!D) return;
  const t = document.createElement("div");
  return t.id = Qr(), t.className = Ce, t.role = "none", t.style.cssText = "position: fixed; top -10px; left: -10px; height: 1px; visibility: hidden;", He(t, (n) => {
    var o;
    if (!D) return;
    const r = ((o = n.borderBoxSize) == null ? void 0 : o[0].inlineSize) ?? n.contentRect.width;
    e.value = nt.get(r);
  }), t;
}
function eo() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      clearTimeout(e[t]);
    });
  }), { timer: e };
}
function to() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      clearInterval(e[t]);
    });
  }), { timer: e };
}
function no() {
  const e = {};
  return Q(() => {
    Object.keys(e).forEach((t) => {
      cancelAnimationFrame(e[t]);
    });
  }), { timer: e };
}
function So() {
  const { timer: e } = eo(), { timer: t } = to(), { timer: n } = no();
  return { timeout: e, interval: t, raf: n };
}
function Oo(e, t, n = 100) {
  let r;
  function o() {
    e.value === "hover" && (clearTimeout(r), r = setTimeout(() => {
      t.value = !0;
    }, n));
  }
  function i() {
    e.value === "hover" && (clearTimeout(r), r = setTimeout(() => {
      t.value = !1;
    }, n));
  }
  function s() {
    e.value === "click" && (t.value = !t.value);
  }
  return {
    handleTriggerEnter: o,
    handleTriggerLeave: i,
    handleTriggerClick: s
  };
}
function ko(e) {
  const {
    items: t,
    itemSize: n,
    itemFixed: r,
    idKey: o,
    defaultKeyAt: i,
    bufferSize: s = k(5),
    wrapper: c = k(null),
    autoResize: a = !0
  } = e, l = W(() => {
    const w = E(t), x = w.length, T = E(o), M = /* @__PURE__ */ new Map();
    for (let A = 0; A < x; ++A)
      M.set(w[A][T], A);
    return M;
  }), f = k(0), d = /* @__PURE__ */ new Map(), p = W(() => {
    const w = E(t), x = w.length, T = E(o), M = En(x, E(n));
    for (let A = 0; A < x; ++A) {
      const N = w[A][T], F = d.get(N);
      F && M.add(A, F);
    }
    return M;
  }), m = k(0), b = k(0), g = W(() => Math.max(
    p.value.boundIndex(b.value) - Math.max(E(s), 0),
    0
  )), v = W(() => {
    if (!f.value || f.value < 0) return [];
    const w = E(t), x = Math.min(
      p.value.boundIndex(b.value + f.value) + 1 + Math.max(E(s), 0),
      w.length
    );
    return w.slice(g.value, x);
  }), h = W(() => {
    m.value;
    const w = p.value.sum(), x = E(r);
    return {
      height: x ? `${w}px` : void 0,
      minHeight: x ? void 0 : `${w}px`,
      boxSizing: "content-box"
    };
  }), u = W(() => (m.value, {
    transform: `translate3d(0, ${p.value.sum(g.value)}px, 0)`
  }));
  if (a) {
    let w = P;
    const x = J(
      () => E(c),
      (T) => {
        w(), T && (He(T, R), w = () => {
          un(T), w = P;
        }, Ke(i) && L(i));
      },
      { immediate: !0, flush: "post" }
    );
    Q(() => {
      x(), w();
    });
  }
  function y() {
    const w = E(c);
    w && (b.value = w.scrollTop);
  }
  function O() {
    Mn(y);
  }
  function R(w) {
    gt(w.target) || w.contentRect.height === f.value || (f.value = w.contentRect.height);
  }
  function S(w, x) {
    var dt, ht;
    if (E(r)) return;
    const T = l.value.get(w), M = p.value, A = M.get(T), N = ((ht = (dt = x.borderBoxSize) == null ? void 0 : dt[0]) == null ? void 0 : ht.blockSize) ?? x.contentRect.height;
    if (N === A) return;
    if (gt(x.target)) {
      A && (M.add(T, -A), m.value++);
      return;
    }
    const F = N - E(n), Z = N - A;
    if (F ? d.set(w, F) : d.delete(w), !Z) return;
    M.add(T, Z), m.value++;
    const ee = E(c);
    if (ee) {
      const hn = M.sum(T);
      ee.scrollTop > hn && ee.scrollBy(0, Z), b.value = ee.scrollTop;
    }
  }
  function C(w, x) {
    const T = E(c);
    T && T.scrollTo({
      behavior: x,
      top: w,
      left: 0
    });
  }
  function z(w, x) {
    const T = E(c);
    T && T.scrollBy({
      behavior: x,
      top: w,
      left: 0
    });
  }
  function L(w, x) {
    const T = l.value.get(w);
    T != null && B(T, x);
  }
  function B(w, x) {
    const T = E(c);
    T && T.scrollTo({
      behavior: x,
      top: p.value.sum(w),
      left: 0
    });
  }
  function H(w, x) {
    const T = E(c);
    if (!T) return;
    const M = p.value, A = T.scrollTop;
    if (M.sum(w) < A) {
      B(w, x);
      return;
    }
    const F = T.offsetHeight, Z = A + F, ee = M.sum(w + 1);
    ee > Z && C(ee - F, x);
  }
  function _(w, x) {
    const T = l.value.get(w);
    T != null && H(T, x);
  }
  return {
    wrapper: c,
    indexMap: l,
    heightTree: p,
    startIndex: g,
    scrollOffset: b,
    visibleItems: v,
    listStyle: h,
    itemsStyle: u,
    handleScroll: O,
    handleResize: R,
    handleItemResize: S,
    scrollTo: C,
    scrollBy: z,
    scrollToKey: L,
    scrollToIndex: B,
    ensureIndexInView: H,
    ensureKeyInView: _
  };
}
export {
  $t as CLICK_OUTSIDE,
  Gr as addActiveThemes,
  so as createSlotRender,
  co as flatVNodes,
  gt as isHiddenElement,
  He as observeResize,
  fo as pickToRefs,
  xo as placementWhileList,
  ao as proxyExposed,
  Vt as queryOutsideHiddenElement,
  To as setActiveThemes,
  un as unobserveResize,
  Re as unrefElement,
  oo as useClickOutside,
  io as useDisplay,
  uo as useFullScreen,
  ho as useHover,
  mo as useIntersection,
  K as useListener,
  po as useManualRef,
  vo as useModifier,
  go as useMounted,
  bo as useMoving,
  yo as usePointer,
  Eo as usePopper,
  no as useRaf,
  wo as useResize,
  Kr as useRtl,
  to as useSetInterval,
  eo as useSetTimeout,
  Ro as useTheme,
  So as useTimerRecord,
  Oo as useTriggerHandler,
  ko as useVirtual,
  lo as watchPauseable
};
//# sourceMappingURL=index.mjs.map
